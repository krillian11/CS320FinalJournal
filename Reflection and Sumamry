For Project One I was tasked with the creation of three services. The services that I created were the contact, task, and appointment services, each of these had their own formulas and functions to handle user data. Looking at the first service created, the contact service, my approach for the service was directly aligned with what the software requirements were. Firstly, the contact segment had to be separated into two unique classes, one being the main contact class and the other being the contact service class that contained a list of contact class objects. As far as the requirements for the default contact class I had to ensure that the contact object had a unique id, first name, and last name that couldn’t be longer than 10 characters, a phone number that is 10 characters, and an address field no longer than 30 characters. I fulfilled these requirements in my code by first creating a constructor and then setting the user data accordingly if it is valid according to the parameters set before. The contact service class wanted a class that was able to add, delete, and edit all information in the contact based on the id. I completed this task by creating three functions that took an ID parameter and for the add function it created a new contact and added it to the list of contacts. For the delete function I searched through the list of contacts with a for loop and if I found a match for the id then I would remove the contact object from the list. The final function, edit contact, works the same way as the delete function, but instead of deleting the data it allows you to change one aspect of the data based on user input. After creating all of the functions required for both contact classes it was time for the JUnit testing and this went “okay”. My testing percentage on this was a 60% and I wasn’t able to change/improve the code to better the positive testing percentage. So I would say that I testing wasn’t effective and definitely needs work. Now onto the task service, similarly to the contact class I took the same approach and decided to use the requirements as my direct guide. For this class we needed to create a task object with an ID, that cannot be longer than 10 characters, a name that cannot be longer than 20 characters, and a description that cannot be longer than 50 characters. I decided to use a constructor to make sure that the data entered cleared the character count requirements set forth and if it did the values would be set. Next I need to create a Task Service, which used the task object. The requirements for the Task Service class were to be able to add,delete, and update tasks based on the id. So using the ID I allowed tasks to be added and removed from the list of Task objects. For the description I allowed the user to change the name and the description if the id is found in the list. The testing for the Task class was one of my best because I was able to make significant changes to the code to improve my test cases to 100%, so my testing was very effective and would have caught problems if there were any. The final class that I was required to create for project one was the hardest one by far! This was the appointment class. The requirements for the appointment class were to create an appointment object that is able to take in an id that is no longer than 10 characters, a date field, and a description that cannot be longer than 50 characters. So just like for the other two classes I used a constructor to help set the values, the only problem with the appointment class was that I wasn’t able to properly compare the date provided with today’s date. The Appointment Service class was just a list of the Appointment objects, and allowed you to add or remove appointments from the list using an ID. For this section of the project my JUnit testing was horrible, I think I had a 15 or 20% because I couldn’t figure out how to test the time for the life of me. This test would not be able to used anywhere because it’s not effective.
The main software testing technique that I used was the State Transition . A State Transition allows you to ensure that the correct data is being entered, as you cannot “move forward” unless you adhere to the rules of the application. This allowed me to test each of the inputs directly to ensure that they work properly with the data given. I used this to ensure that all of the information entered would match the character count parameters, and if they didn’t it would display an error message saying “Invalid Data Entered -[varname]”. The only other option that I would’ve chosen would have been the Boundary Value Analysis. This is because Boundary Value Analysis is when you check random values in between the max and min case as well as the max and min cases, this ensures that the edge casing is fine and that most of the data in the middle is covered as well. The mindset that I had when I was working on this project was to act as if I was publishing this as an actual real world project. With this mindset I tried my best to ensure a high percent testing rate. It is important to ensure that you appreciate the complexity along with the interrelationships of the code because after many small parts are put together you get a complex program like the one that we made that takes in user data and uses different objects and functions to store that data. As far as bias goes in this code I made sure that after I finished programming I waited for an hour or two before trying to implement any testing features. I also had my mom and dad test some of the functionalities while I watched to see if there were any tests that I missed. When writing professional code it is important to not cut corners because that causes you to miss functions that are needed or it will cause you to forget certain security tests. I will try to manage technical debt by not always using the fastest solution, I will try to find solutions that will increase the programs runtime and productivity over choosing production/release of product speed.
